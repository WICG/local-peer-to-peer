<pre class='metadata'>
Title: Local Peer-to-Peer API
Shortname: local-peer-to-peer
Level: 1
Status: CG-DRAFT
Group: WICG
Repository: WICG/local-peer-to-peer
URL: https://WICG.github.io/local-peer-to-peer/
Editor: Anssi Kostiainen, Intel https://intel.com, anssi.kostiainen@intel.com
Editor: Belem Zhang, Intel https://intel.com, belem.zhang@intel.com
Editor: Michiel De Backker, Twintag https://twintag.com, mail@backkem.me
Editor: Wei Wang, Intel https://intel.com, wei4.wang@intel.com
!Tests: <a href=https://github.com/w3c/web-platform-tests/tree/master/local-peer-to-peer>web-platform-tests local-peer-to-peer/</a> (<a href=https://github.com/w3c/web-platform-tests/labels/local-peer-to-peer>ongoing work</a>)
Abstract: Local Peer-to-Peer is a Web platform API proposal for local communication between browsers without the aid of a server.
Markup Shorthands: markdown yes, dfn yes, idl yes, markup yes
</pre>

Note: This specification is under active development and therefore incomplete. If you're looking for an overview of the proposal, please refer to the [Explainer](https://github.com/WICG/local-peer-to-peer/blob/main/EXPLAINER.md).

Introduction {#intro}
=====================

*This section is non-normative.*

The Local Peer-to-Peer API aims to give browsers the means to communicate directly, without the aid of a server in the middle. It is designed to enable this communication within the confines of a local communication medium such as the Local Area Network.

Many modern Web security measures rely on the presence of naming, signaling and certificate authorities. Local use-cases where these authorities are not readily available have started lagging behind in user experience or are not supported altogether. The Local Peer-to-Peer API aims to bring back first-class support for local communication use-cases while working within the same strict user-friendliness, security and privacy requirements.

Examples of potential uses of this API include: Collaboration tools that work during an internet outage or emergency situations, connecting to your NAS, your home security system, your robotic assistant doing the dishes or your GPU farm in the basement that's running your personalized virtual assistant.

This specification aims to strike a balance between creating a powerful new building block for developers and providing a seamless, secure and privacy preserving experience for browser users. As an example: while the API doesn't provide raw socket access, it does aim to give developers the flexibility to innovate on top by providing a persistent, two-way communication channel with little overhead.

The API is designed to be backed by an authenticated, streams-based transport. As a commitment to an open standards-based implementation path, this specification describes how the API can be implemented on top of the [Open Screen Protocol](https://w3c.github.io/openscreenprotocol/). While not described here, the API is expected to be implementable on top of other transports when technically feasible.

Peer Management {#peer-management}
==================================

Note: This section and its subsections use RFC 2119 terminology in a relaxed manner. These sections will be converted into well-defined algorithmic normative prose informed by further implementation experience. For now, this relaxed description better allows for rapid prototyping.

The user agent is in charge of managing peers.

A <dfn>peer</dfn> is an equal participants in the network that forms a peer-to-peer network of nodes. These nodes can communicate without the need for a central coordination by a server.

A user agent has an associated <dfn>local peer-to-peer manager</dfn> in charge of managing [=peers=]. Its responsibility is to [=start local peer discovery=], [=establish local peer connections=] and [=acquire a local peer grant=] on a per-origin basis. This is done to avoid exposing information about a user's local network topology.

Known peers {#known-peers}
--------------------------

The user agent should maintain a list of peers that it has knowledge of.

The [=local peer-to-peer manager=] has an associated <dfn>known peers map</dfn>, an [=/ordered map=] of [=known peers=]. Each <dfn>known peer</dfn> is a [=peer=] that has an associated <dfn>authentication state</dfn> and <dfn>peer grant state</dfn>. The user agent keeps track of these states per origin. Unless [=persisted=], both the states are initially false.

The user agent may persist known peers, their authentication state and/or peer grant states. If the user agent chooses to do so, it must do so in accordance with the [[!openscreenprotocol|OpenScreen Protocol]] Persistent State rules. Such a peer or its state is said to be <dfn>persisted</dfn>.

Peer advertisement {#peer-advertisement}
----------------------------------------

The user agent can make itself discoverable by advertising using the [=session/advertise agent=] capability.

Note: The user agent must get the user's explicit consent in order to start advertising.

When advertising, the user agent must listen for incoming peer connections. In case a connection is received, the peer is added to the known peer list. The user agent must not directly provide access to the incoming peer connection to any origin. Instead, the user agent must prompt to [grant peer](#peer-grant) access to the origin that initiated peer advertisement.

Peer discovery {#peer-discovery}
--------------------------------

The user agent can discover local peers using the [=session/discover agents=] capability.

When asked to <dfn>start local peer discovery</dfn>, the user agent discovers local peers using the [=session/discover agents=] capability.

If a peer is discovered, the user agent should add it to the [=known peers map=]. The user agent must never expose the full result of peer discovery with an origin. Instead, the user agent must [=acquire a local peer grant=] to grant access to a peer to the origin that initiated the peer request.

Peer authentication {#peer-authentication}
------------------------------------------

The user agent can initiate authentication with a peer using the [=session/authenticate an agent=] capability.

When asked to <dfn>authenticate a local peer</dfn>, the user agent must initiate authentication with a local peer using the [=session/authenticate an agent=] capability. The peer's [=authentication state=] must be set to true if authentication succeeds, otherwise false.

A peer is said to be <dfn>authenticated</dfn> when its [=authentication state=] is true.

Peer grant {#peer-grant}
------------------------------------

The user agent, with the user's consent, must [=acquire a local peer grant=] for an origin to get access to a peer.

Note: The user agent must get the user's explicit consent in order to grant an origin access to a peer. For enhanced privacy protection, the user agent must provide means to dismiss any related user interface and this action must not be detectable by script or have script-observable side-effects. The user interface may provide means to revoke the grant or to make the grant [=persisted=].

When asked to <dfn>acquire a local peer grant</dfn>, the user agent displays the [=known peers=] to the user through its native user interface. When the user selects a peer from the user interface, the user agent must check the selected peer is [=authenticated=], and run the [=authenticate a local peer=] algorithm otherwise, and set the [=peer grant state=] according to the user's explicit selection.

Protocol concepts {#protocol-concepts}
======================================

When asked to <dfn>establish local peer connection</dfn>, the user agent ...

A <dfn for="protocol">Local Peer-to-Peer session</dfn> represents an authenticated [[!RFC9000|QUIC]] connection as defined in [[!openscreenprotocol|Open Screen Protocol]] or OSP.

A [=Local Peer-to-Peer session=] has the following capabilities:

<table class="data" dfn-for="session">
 <thead>
  <tr>
   <th>capability
   <th>definition
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><dfn>advertise agent</dfn>
   <td>[[!openscreenprotocol]]
   [discovery](https://www.w3.org/TR/openscreenprotocol/#discovery)
  </tr>
  <tr>
   <td><dfn>discover agents</dfn>
   <td>[[!openscreenprotocol]]
   [discovery](https://www.w3.org/TR/openscreenprotocol/#discovery)
  </tr>
  <tr>
   <td><dfn>discover metadata</dfn>
   <td>[[!openscreenprotocol]]
   [transport](https://www.w3.org/TR/openscreenprotocol/#transport)
  </tr>
  <tr>
   <td><dfn>authenticate an agent</dfn>
   <td>[[!openscreenprotocol]]
   [authentication](https://www.w3.org/TR/openscreenprotocol/#authentication)
  </tr>
  <tr>
   <td>[=open a data channel=]
   <td>[[#data-channel-extension]]
  </tr>
  <tr>
   <td>[=send data on a channel=]
   <td>[[#data-channel-extension]]
  </tr>
  <tr>
   <td>[=open a WebTransport session=]
   <td>[[#webtransport-extension]]
  </tr>
 </tbody>
</table>

Part of these capabilities are defined below as [protocol extensions](https://www.w3.org/TR/openscreenprotocol/#protocol-extensions) to the [[!openscreenprotocol|OpenScreen Protocol]].

Data channel extension {#data-channel-extension}
------------------------------------------------

In order to signal support for this protocol extension, the agent should include the [=data-channels=] [=agent-capability=] as part of the [agent-info-response](https://www.w3.org/TR/openscreenprotocol/#agent-info-response) message exchanged during [=discover metadata=].

To <dfn>open a data channel</dfn> an agent may send a [=data-channel-open-request=] message on a new [[!RFC9000|QUIC]] stream. The [=Local Peer-to-Peer session=] must be authenticated. The message must contain the following values:

: channel-id
:: An ID number (between 0 and 65,534) which uniquely identifies the data channel.  Must not be empty.

: label
:: a string that contains a name describing the data channel. These labels are not required to be unique.

: protocol
:: a string containing the name of the subprotocol in use. If no protocol was specified when the data channel was created, then this property's value is the empty string ("").

When the receiver receives the [=data-channel-open-request=], it should send back a [=data-channel-open-response=] message. The response must include the following:

: result
:: a code indicating success or failure, and the reason for the failure.

If the [=data-channel-open-response=] message indicates success, the data channel is considered open. Agents can now <dfn>send data on a channel</dfn> by sending [=data-frame=] messages on the same [[!RFC9000|QUIC]] stream the data channel was opened. The message must include the following:

: encoding-id
:: Determines the encoding of the data being sent. The values are specified as [=data-channel-encoding-id=]:
    0: [=encoding-id-blob|Blob=];
    1: [=encoding-id-string|String=];
    2: [=encoding-id-array-buffer|ArrayBuffer=].

: payload
:: The binary representation of the data being sent.

WebTransport extension {#webtransport-extension}
------------------------------------------------

The protocol extension to [=send data on a channel=] provides an ergonomic way to send simple messages. An agent can [=open a WebTransport session=] for communication that requires low overhead and more granular streams control.

In order to signal support for this protocol extension, the agent should include the [=quick-transport=] [=agent-capability=] as part of the [agent-info-response](https://www.w3.org/TR/openscreenprotocol/#agent-info-response) message exchanged during [=discover metadata=].

An agent can <dfn>open a WebTransport session</dfn> by dialing a new [[!RFC9000|QUIC]] connection using the agent certificates established during [=authenticate an agent=]. During connection establishment, the ALPN token "q2q" must be used in the TLS handshake.

The capabilities of the Local WebTransport session are defined in [[!webtransport]].

Note: The WebTransport-over-QUIC protocol is yet to be defined. Potentially considering earlier work such as [draft-vvv-webtransport-quic](https://datatracker.ietf.org/doc/html/draft-vvv-webtransport-quic-02).

Appendix A: OSP Extension Messages {#appendix-a}
================================================

The following messages are defined according to and as an extension to the [[!openscreenprotocol|OpenScreen Protocol]] [Messages](https://www.w3.org/TR/openscreenprotocol/#appendix-a).

Note: The type keys and capability IDs for these extensions are not officially registered yet. They will be registered as this specification matures. 

<pre class="data" highlight='cddl'>
<dfn>agent-capability</dfn> = &(
  <dfn>data-channels</dfn>: 11OO
  <dfn>quick-transport</dfn>: 12OO
)

<dfn>data-channel-encoding-id</dfn> = &(
  <dfn>encoding-id-blob</dfn>: 0
  <dfn>encoding-id-string</dfn>: 1
  <dfn>encoding-id-array-buffer</dfn>: 2
)

; type key 24
<dfn>data-frame</dfn> = {
  0: data-channel-encoding-id ; encoding-id
  4: bytes ; payload
}

; type key 1101
<dfn>data-channel-open-request</dfn> = {
  request
  1: uint ; channel-id
  2: text ; label
  3: text ; protocol
}

; type key 1102
<dfn>data-channel-open-response</dfn> = {
  response
  1: &result ; result
}
</pre>